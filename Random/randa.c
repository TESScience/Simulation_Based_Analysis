/* jpd 5/14/86 */

#include "randa.h"

/* Additive random number generator V3.0 */

/* rand() returns a pseudo-random nonnegative int uniformly
   distributed over the (machine dependent) available range.
   The sequence repetition period is at least 2**55-1.
   This generator substitutes for the standard C library
   function. The low order bits are much more random than
   those generated by the usual linear congruential method.
   This may be an advantage in some Monte Carlo methods when
   numbers are compared with small thresholds to generate
   infrequent events. See Knuth: Seminumerical Algorithms
   Page 27 for details of the algorithm. This version generates
   numbers wholesale for efficiency. The rand() function is
   available as a macro in rand.h for maximum efficiency.
   Also available as a macro is urand() which returns a
   uniformly distributed unsigned value.
*/

/* The following two constants define
   a primitive trinomial mod 2.
*/

// Order 55 passes all dieharder tests
#define LENGTH 55
#define TAP 24

// Order 18 fails diehard_squeeze, marsaglia_tsang_gcd, dab_bytedistrib, 
//  dab_filltree.
// #define LENGTH 18
// #define TAP 7

// Order 23 fails diehard_squeeze
// #define LENGTH 23
// #define TAP 5


unsigned *_rnbp;
short _rncnt = 0;
unsigned _nrnbuf();

static char inited = 0;
static unsigned rnbuf[ LENGTH ];

/* Initialize the random number buffer.
	srand( new ) makes a fresh random number buffer in
	a way that depends chaotically on the the value of
	the seed "new". The method is to set the first location
	in the buffer to one, and the remainder to successively
	shifted seed values. This guarantees that the least
	significant bits are unique (at least for machines with <55
	bit words, and that they contain at least one nonzero bit.
	This in turn guarantess that the generator will function
	and will generate a unique sequence. The generator is then
	cycled once per bit of word length to
	thoroughly scramble the initialization pattern.
	srand( 1 ) will restart the sequence at its usual starting
	point.
*/

void randa_srand( int new )
{
	register unsigned *p = rnbuf + LENGTH;
	register unsigned rnew = new;
	register unsigned c;

	*--p = 1;

	while( p > rnbuf ) {
		*--p =  rnew;
		rnew >>= 1;
	}
	inited = 1;		/* Avoid recursive call from _nrnbuf! */

	for( c = -1; c != 0; c >>= 1 ) _nrnbuf();	/* Shake Well */

	_rncnt = 0;		/* start at consistent phase */
}


/* Fill the buffer with fresh random numbers */

unsigned _nrnbuf( void )
{
	register unsigned tmp;
	register unsigned *k = rnbuf + LENGTH;
	register unsigned *j = rnbuf + TAP;

	if( ! inited ) randa_srand( 1 );

	while( j > rnbuf) {
		tmp = *--k + *--j;
		*k = tmp;
	}
	j = rnbuf + LENGTH;
	while( k > rnbuf ) {
		tmp = *--k + *--j;
		*k = tmp;
	}

	_rnbp = rnbuf + LENGTH - 2;
	_rncnt = LENGTH - 1;
	return( rnbuf[ LENGTH - 1 ]);
}


int randa_rand( void )		/* For things that don't use the macro */
{
	if( --_rncnt < 0 ) return( _nrnbuf() >> 1 );
	else return( *_rnbp-- >> 1 );
}

unsigned randa_urand( void )	/* For things that don't use the macro */
{
	if( --_rncnt < 0 ) return( _nrnbuf());
	else return( *_rnbp-- );
}
